"""    üåë ShadowTikTok - –ò–∑–≤–ª–µ–∫–∞—Ç–µ–ª—å –º–µ–¥–∏–∞ –∏–∑ –ë–µ–∑–¥–Ω—ã    –ú–æ–¥—É–ª—å –¥–ª—è —Å–∫–∞—á–∏–≤–∞–Ω–∏—è –∫–æ–Ω—Ç–µ–Ω—Ç–∞ –∏–∑ TikTok (–≤–∏–¥–µ–æ/—Ñ–æ—Ç–æ) –±–µ–∑ –≤–æ–¥—è–Ω—ã—Ö –∑–Ω–∞–∫–æ–≤."""from .. import loader, utilsimport aiohttpimport ioimport asyncioimport logginglogger = logging.getLogger(__name__)# üõ°Ô∏è –°–∞–∫—Ä–∞–ª—å–Ω–∞—è –°—Ç—Ä—É–∫—Ç—É—Ä–∞version = (1, 6, 0) # –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è# meta developer: @HarutyaModules# scope: hikka_only# meta fhsdesc: #ShadowTikTok #tiktok #–≤–∏–¥–µ–æ #—Ñ–æ—Ç–æ #–±–µ–∑_–≤–º #—Å–∫–∞—á–∏–≤–∞–Ω–∏–µ #–∞–ª—å–±–æ–º—ã@loader.tdsclass ShadowTikTokMod(loader.Module):    """    –°–∫–∞—á–∏–≤–∞–µ—Ç –≤–∏–¥–µ–æ –∏–ª–∏ —Ñ–æ—Ç–æ –∏–∑ TikTok –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞,    –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –æ–ø—Ä–µ–¥–µ–ª—è—è —Ç–∏–ø –∫–æ–Ω—Ç–µ–Ω—Ç–∞. –§–æ—Ç–æ –æ—Ç–ø—Ä–∞–≤–ª—è—é—Ç—Å—è –∞–ª—å–±–æ–º–æ–º.    –ö–æ–º–∞–Ω–¥–∞: .tt <—Å—Å—ã–ª–∫–∞>    """    strings = {        "name": "ShadowTikTok",        "loading": "<b>üåë –ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ –ø–æ—Ç–æ–∫—É –¥–∞–Ω–Ω—ã—Ö...</b>",        "downloading_video": "<b>üì• –ò–∑–≤–ª–µ–∫–∞—é –º–∞—Ç–µ—Ä–∏—é (–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ)...</b>",        "downloading_photos": "<b>üì∏ –ò–∑–≤–ª–µ–∫–∞—é –º–∞—Ç–µ—Ä–∏—é (–°–∫–∞—á–∏–≤–∞–Ω–∏–µ {count} —Ñ–æ—Ç–æ)...</b>",        "uploading_photos": "<b>üì§ –ú–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è (–û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª—å–±–æ–º–∞)...</b>", # NEW        "no_args": "<b>‚ùå –•–æ–∑—è–π–∫–∞, –í—ã –Ω–µ –¥–∞–ª–∏ –º–Ω–µ —Ü–µ–ª—å (–°—Å—ã–ª–∫—É).</b>",        "error_api": "<b>‚ö†Ô∏è –≠—Ñ–∏—Ä –æ—Ç–≤–µ—Ä–≥ –∑–∞–ø—Ä–æ—Å. –í–æ–∑–º–æ–∂–Ω–æ, —Å—Å—ã–ª–∫–∞ –º–µ—Ä—Ç–≤–∞ –∏–ª–∏ —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.</b>",        "error_net": "<b>üö´ –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–µ–∑–¥–Ω–æ–π.</b>",        "no_media_found": "<b>‚ùå –í –ë–µ–∑–¥–Ω–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –≤–∏–¥–µ–æ, –Ω–∏ —Ñ–æ—Ç–æ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ.</b>",    }    strings_ru = {        "loading": "<b>üåë –ü–æ–¥–∫–ª—é—á–∞—é—Å—å –∫ –ø–æ—Ç–æ–∫—É –¥–∞–Ω–Ω—ã—Ö...</b>",        "downloading_video": "<b>üì• –ò–∑–≤–ª–µ–∫–∞—é –º–∞—Ç–µ—Ä–∏—é (–°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤–∏–¥–µ–æ)...</b>",        "downloading_photos": "<b>üì∏ –ò–∑–≤–ª–µ–∫–∞—é –º–∞—Ç–µ—Ä–∏—é (–°–∫–∞—á–∏–≤–∞–Ω–∏–µ {count} —Ñ–æ—Ç–æ)...</b>",        "uploading_photos": "<b>üì§ –ú–∞—Ç–µ—Ä–∏–∞–ª–∏–∑–∞—Ü–∏—è (–û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª—å–±–æ–º–∞)...</b>",        "no_args": "<b>‚ùå –•–æ–∑—è–π–∫–∞, –í—ã –Ω–µ –¥–∞–ª–∏ –º–Ω–µ —Ü–µ–ª—å (–°—Å—ã–ª–∫—É).</b>",        "error_api": "<b>‚ö†Ô∏è –≠—Ñ–∏—Ä –æ—Ç–≤–µ—Ä–≥ –∑–∞–ø—Ä–æ—Å. –í–æ–∑–º–æ–∂–Ω–æ, —Å—Å—ã–ª–∫–∞ –º–µ—Ä—Ç–≤–∞ –∏–ª–∏ —Å–µ—Ä–≤–∏—Å –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω.</b>",        "error_net": "<b>üö´ –û—à–∏–±–∫–∞ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è —Å –ë–µ–∑–¥–Ω–æ–π.</b>",        "no_media_found": "<b>‚ùå –í –ë–µ–∑–¥–Ω–µ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ –Ω–∏ –≤–∏–¥–µ–æ, –Ω–∏ —Ñ–æ—Ç–æ –ø–æ —ç—Ç–æ–π —Å—Å—ã–ª–∫–µ.</b>",    }    async def client_ready(self, client, db):        self.client = client        self.db = db    async def _fetch_tiktok_api_data(self, url, session, headers):        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–∏—Ç—É–∞–ª: –∑–∞–ø—Ä–æ—Å –º–µ—Ç–∞–¥–∞–Ω–Ω—ã—Ö —É —Ç–µ–Ω–µ–≤—ã—Ö —à–ª—é–∑–æ–≤ TikTok."""        async with session.post(            "https://www.tikwm.com/api/",             data={"url": url},             headers=headers        ) as response:            data = await response.json()        if "data" not in data:            err_msg = data.get('msg', 'Unknown Error')            raise ValueError(f"{self.strings('error_api')}\nLog: {err_msg}")                video_url = data["data"].get("play")        image_urls = data["data"].get("images")        title = data["data"].get("title", "ShadowTikTok Media")        author = data["data"].get("author", {}).get("nickname", "Unknown")                return video_url, image_urls, title, author    async def _send_video(self, message, status_msg, video_url, title, author, reply_to, session, headers):        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–∏—Ç—É–∞–ª: –æ—Ç–ø—Ä–∞–≤–∫–∞ –≤–∏–¥–µ–æ."""        await utils.answer(status_msg, self.strings("downloading_video"))                async with session.get(video_url, headers=headers) as vid_stream:            video_bytes = await vid_stream.read()        file = io.BytesIO(video_bytes)        file.name = f"TikTok_{author}.mp4"                caption_base = (            f"<b>üé• Author:</b> {utils.escape_html(author)}\n"            f"<b>üìù Title:</b> {utils.escape_html(title)}"        )                await self.client.send_file(            message.chat_id,            file,            caption=caption_base,            reply_to=reply_to,            parse_mode="HTML"        )        await status_msg.delete()    async def _send_photos(self, message, status_msg, image_urls, title, author, reply_to, session, headers):        """–í–Ω—É—Ç—Ä–µ–Ω–Ω–∏–π —Ä–∏—Ç—É–∞–ª: –æ—Ç–ø—Ä–∞–≤–∫–∞ —Ñ–æ—Ç–æ (–∞–ª—å–±–æ–º–∞–º–∏)."""        await utils.answer(status_msg, self.strings("downloading_photos").format(count=len(image_urls)))        caption_base = (            f"<b>üé• Author:</b> {utils.escape_html(author)}\n"            f"<b>üìù Title:</b> {utils.escape_html(title)}"        )        media_files = []        # 1. –°–∫–∞—á–∏–≤–∞–Ω–∏–µ –≤—Å–µ—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –ø–∞–º—è—Ç—å        for idx, img_url in enumerate(image_urls):            async with session.get(img_url, headers=headers) as img_stream:                content_type = img_stream.headers.get('Content-Type')                image_bytes = await img_stream.read()            file = io.BytesIO(image_bytes)                        # –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–∞—Å—à–∏—Ä–µ–Ω–∏—è            file_ext = 'jpg'            if content_type:                if 'jpeg' in content_type or 'jpg' in content_type: file_ext = 'jpg'                elif 'png' in content_type: file_ext = 'png'                elif 'gif' in content_type: file_ext = 'gif'                elif 'webp' in content_type: file_ext = 'webp'                else: file_ext = img_url.split('.')[-1] if '.' in img_url else 'jpg'            else:                file_ext = img_url.split('.')[-1] if '.' in img_url else 'jpg'            file.name = f"TikTok_{author}_{idx+1}.{file_ext}"            media_files.append(file)        # 2. –û—Ç–ø—Ä–∞–≤–∫–∞ –∞–ª—å–±–æ–º–∞–º–∏ (–≥—Ä—É–ø–ø–∏—Ä–æ–≤–∫–∞ –ø–æ 10 —à—Ç—É–∫, —Ç–∞–∫ –∫–∞–∫ —ç—Ç–æ –ª–∏–º–∏—Ç Telegram)        await utils.answer(status_msg, self.strings("uploading_photos"))                chunk_size = 10        chunks = [media_files[i:i + chunk_size] for i in range(0, len(media_files), chunk_size)]        for i, chunk in enumerate(chunks):            # –ü–æ–¥–ø–∏—Å—å –¥–æ–±–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –∫ –ø–µ—Ä–≤–æ–º—É –∞–ª—å–±–æ–º—É, —á—Ç–æ–±—ã –Ω–µ —Å–ø–∞–º–∏—Ç—å —Ç–µ–∫—Å—Ç–æ–º            caption = caption_base if i == 0 else ""                        await self.client.send_file(                message.chat_id,                file=chunk,                caption=caption,                reply_to=reply_to,                parse_mode="HTML"            )                        # –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É –∞–ª—å–±–æ–º–∞–º–∏, –µ—Å–ª–∏ –∏—Ö –Ω–µ—Å–∫–æ–ª—å–∫–æ            if len(chunks) > 1:                await asyncio.sleep(1)        await status_msg.delete()    async def _process_command(self, message):        """–ï–¥–∏–Ω—ã–π –º–µ—Ö–∞–Ω–∏–∑–º –æ–±—Ä–∞–±–æ—Ç–∫–∏ —Å—Å—ã–ª–∫–∏ –¥–ª—è –∫–æ–º–∞–Ω–¥—ã .tt"""        args = utils.get_args_raw(message)        reply = await message.get_reply_message()        url = None        reply_to = None        if args:            url = args            reply_to = message.reply_to_msg_id        elif reply:            url = reply.raw_text            reply_to = reply.id                if not url:            await utils.answer(message, self.strings("no_args"))            return        status_msg = await utils.answer(message, self.strings("loading"))        headers = {            "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36",            "Accept-Encoding": "gzip, deflate",            "Accept-Language": "en-US,en;q=0.9",        }        try:            async with aiohttp.ClientSession() as session:                video_url, image_urls, title, author = await self._fetch_tiktok_api_data(url, session, headers)                if image_urls and isinstance(image_urls, list) and image_urls:                    await self._send_photos(message, status_msg, image_urls, title, author, reply_to, session, headers)                elif video_url:                    await self._send_video(message, status_msg, video_url, title, author, reply_to, session, headers)                else:                    await utils.answer(status_msg, self.strings("no_media_found"))                    await status_msg.delete()                if not reply and message.is_private:                     await message.delete()        except ValueError as ve:            logger.exception(f"–û—à–∏–±–∫–∞ API –≤ ShadowTikTok: {ve}")             await utils.answer(status_msg, f"{ve}")        except Exception as e:            logger.exception(f"–ù–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ –≤ ShadowTikTok: {e}")             await utils.answer(status_msg, f"{self.strings('error_net')}\n<code>{utils.escape_html(str(e))}</code>")    @loader.command(name="tt", ru_doc="<—Å—Å—ã–ª–∫–∞> - –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ –∏–ª–∏ —Ñ–æ—Ç–æ –∏–∑ TikTok")    async def ttcmd(self, message):        """<—Å—Å—ã–ª–∫–∞> - –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ –∏–ª–∏ —Ñ–æ—Ç–æ –∏–∑ TikTok"""        await self._process_command(message)