"""    üé• AutoMedia Pro - –£–º–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ –º–µ–¥–∏–∞        –û—Ç–ø—Ä–∞–≤–ª—è–µ—Ç —Ñ–æ—Ç–æ/–≤–∏–¥–µ–æ –ø–æ —Ç—Ä–∏–≥–≥–µ—Ä—É.    –ü–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç:     - –û–≥—Ä–æ–º–Ω—ã–µ –∞—Ä—Ö–∏–≤—ã (60–∫+ —Ñ–æ—Ç–æ)    - –ì–∏–±–∫—É—é –Ω–∞—Å—Ç—Ä–æ–π–∫—É —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤ (—Ç–µ–∫—Å—Ç/—Ä–µ–ø–ª–∞–π)    - –°–µ—Ä–≤–µ—Ä–Ω—ã–π –ø–æ–∏—Å–∫ –ø–æ —Ç–µ–≥–∞–º    - –ú–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã–µ –∏—Å—Ç–æ—á–Ω–∏–∫–∏    - –§–∏–ª—å—Ç—Ä–∞—Ü–∏—é –ø–æ –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏"""__version__ = (2, 6, 3) # –û–±–Ω–æ–≤–ª–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è# meta developer: @harutyamodules# scope: hikka_only# scope: hikka_min 1.3.0# requires: telethon# meta fhsdesc: #AutoMediaPro #–º–µ–¥–∏–∞ #–∞–≤—Ç–æ–æ—Ç–≤–µ—Ç—á–∏–∫ #—Ñ–æ—Ç–æ #–≤–∏–¥–µ–æ #–≥–∏—Ñ #—Ç–µ–≥–∏ #–ø–µ—Ä–≤—ã–π_—Å_—Ç–µ–≥–æ–º #–ª–∞–π—Çfrom .. import loader, utilsfrom herokutl.types import Messagefrom telethon import types, errorsimport loggingimport randomimport timeimport reimport iologger = logging.getLogger(__name__)@loader.tdsclass AutoMediaProMod(loader.Module):    """–ü—Ä–æ–¥–≤–∏–Ω—É—Ç–∞—è –∞–≤—Ç–æ-–æ—Ç–ø—Ä–∞–≤–∫–∞ –º–µ–¥–∏–∞. Lite –≤–µ—Ä—Å–∏—è."""        strings = {        "name": "AutoMediaPro",        "added": "‚úÖ <b>Media added!</b>\nID: <code>{}</code>\nSource: <b>{}</b>\nTags: {}",        "list_empty": "‚ùå <b>List is empty or no matching media found!</b>",        "not_media": "‚ùå <b>Reply to media!</b>",        "stats": (            "üìä <b>AutoMedia Stats:</b>\n"            "üóÑ <b>DB Size:</b> {}\n"            "üëÅ <b>History (Sent):</b> {}\n"            "üì∫ <b>Channels:</b> {}\n"            "üéØ <b>Trigger Mode:</b> {}\n"            "‚è± <b>Duration:</b> {}-{}s"        ),        "cleared": "‚úÖ <b>History cleared!</b> Cycle restarted.",        "not_in_db": "‚ùå <b>Media not found in database!</b> (Reply to the message in Saved Messages)",        "send_err": "‚ùå <b>Could not send media here (Restricted).</b>",    }        strings_ru = {        "added": "‚úÖ <b>–ú–µ–¥–∏–∞ –¥–æ–±–∞–≤–ª–µ–Ω–æ!</b>\nID: <code>{}</code>\n–ò—Å—Ç–æ—á–Ω–∏–∫: <b>{}</b>\n–¢–µ–≥–∏: {}",        "list_empty": "‚ùå <b>–°–ø–∏—Å–æ–∫ –ø—É—Å—Ç –∏–ª–∏ –Ω–µ—Ç –ø–æ–¥—Ö–æ–¥—è—â–∏—Ö –º–µ–¥–∏–∞!</b>",        "not_media": "‚ùå <b>–û—Ç–≤–µ—Ç—å –Ω–∞ –º–µ–¥–∏–∞!</b>",        "stats": (            "üìä <b>–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ AutoMedia:</b>\n"            "üóÑ <b>–í –±–∞–∑–µ:</b> {}\n"            "üëÅ <b>–û—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ (–ò—Å—Ç–æ—Ä–∏—è):</b> {}\n"            "üì∫ <b>–ö–∞–Ω–∞–ª—ã:</b> {}\n"            "üéØ <b>–†–µ–∂–∏–º —Ç—Ä–∏–≥–≥–µ—Ä–∞:</b> {}\n"            "‚è± <b>–î–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å:</b> {}-{}—Å"        ),        "cleared": "‚úÖ <b>–ò—Å—Ç–æ—Ä–∏—è –æ—á–∏—â–µ–Ω–∞!</b> –¶–∏–∫–ª –ø–µ—Ä–µ–∑–∞–ø—É—â–µ–Ω.",        "not_in_db": "‚ùå <b>–ú–µ–¥–∏–∞ –Ω–µ—Ç –≤ –±–∞–∑–µ!</b> (–ù—É–∂–Ω–æ –æ—Ç–≤–µ—á–∞—Ç—å –Ω–∞ —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –ò–∑–±—Ä–∞–Ω–Ω–æ–º)",        "send_err": "‚ùå <b>–ù–µ –º–æ–≥—É –æ—Ç–ø—Ä–∞–≤–∏—Ç—å –º–µ–¥–∏–∞ (–ó–∞–ø—Ä–µ—â–µ–Ω–æ –≤ —á–∞—Ç–µ).</b>",    }    def __init__(self):        self.config = loader.ModuleConfig(            loader.ConfigValue(                "trigger_word",                "–µ—â–µ",                "–°–ª–æ–≤–æ-—Ç—Ä–∏–≥–≥–µ—Ä (–Ω–∏–∂–Ω–∏–π —Ä–µ–≥–∏—Å—Ç—Ä)",                validator=loader.validators.String()            ),            loader.ConfigValue(                "trigger_mode",                "any",                "–†–µ–∂–∏–º —Å—Ä–∞–±–∞—Ç—ã–≤–∞–Ω–∏—è",                validator=loader.validators.Choice(["any", "reply", "text"])            ),            loader.ConfigValue(                "cooldown",                10,                "–ö—É–ª–¥–∞—É–Ω –≤ —Å–µ–∫—É–Ω–¥–∞—Ö",                validator=loader.validators.Integer(minimum=0)            ),            loader.ConfigValue(                "media_type",                "all",                "–¢–∏–ø –º–µ–¥–∏–∞ –¥–ª—è –æ—Ç–ø—Ä–∞–≤–∫–∏",                validator=loader.validators.Choice(["all", "photo", "video", "gif"])            ),            loader.ConfigValue(                "send_count",                1,                "–°–∫–æ–ª—å–∫–æ —Ñ–∞–π–ª–æ–≤ –æ—Ç–ø—Ä–∞–≤–ª—è—Ç—å –∑–∞ —Ä–∞–∑",                validator=loader.validators.Integer(minimum=1, maximum=10)            ),            loader.ConfigValue(                "min_duration",                0,                "–ú–∏–Ω–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–∏–¥–µ–æ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (0 = –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞)",                validator=loader.validators.Integer(minimum=0)            ),            loader.ConfigValue(                "max_duration",                300,                "–ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏—Ç–µ–ª—å–Ω–æ—Å—Ç—å –≤–∏–¥–µ–æ –≤ —Å–µ–∫—É–Ω–¥–∞—Ö (0 = –±–µ–∑ —Ñ–∏–ª—å—Ç—Ä–∞)",                validator=loader.validators.Integer(minimum=0)            ),            loader.ConfigValue(                "channel",                "",                "–ò—Å—Ç–æ—á–Ω–∏–∫–∏ —á–µ—Ä–µ–∑ –∑–∞–ø—è—Ç—É—é (@cats, @dogs). –ü—É—Å—Ç–æ = —Ä—É—á–Ω–æ–π —Ä–µ–∂–∏–º.",                validator=loader.validators.String()            ),            loader.ConfigValue(                "loop_media",                True,                "–û—á–∏—â–∞—Ç—å –∏—Å—Ç–æ—Ä–∏—é, –∫–æ–≥–¥–∞ –º–µ–¥–∏–∞ –∑–∞–∫–∞–Ω—á–∏–≤–∞—é—Ç—Å—è (—Ü–∏–∫–ª–∏—á–Ω—ã–π —Ä–µ–∂–∏–º)",                validator=loader.validators.Boolean()            ),        )        self.last_triggered = 0    async def client_ready(self, client, db):        self._client = client        self._db = db        self.media_list = self.pointer("media_list", [])        self.sent_history = self.pointer("sent_history", [])         self.tags_db = self.pointer("media_tags", {})        self.me_id = (await client.get_me()).id    def _extract_hashtags(self, text):        if not text: return []        return list(set(re.findall(r"#\w+", text.lower())))    def _clean_tag(self, tag):        return tag.lstrip("#").lower()    def _get_query_tags(self, text, trigger):        if not text: return []        lower_text = text.lower()                # –ï—Å–ª–∏ —Ç—Ä–∏–≥–≥–µ—Ä –µ—Å—Ç—å –≤ —Ç–µ–∫—Å—Ç–µ, —É–±–∏—Ä–∞–µ–º –µ–≥–æ, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ —Ç–µ–≥–∏        if trigger in lower_text:            query = lower_text.replace(trigger, "").strip()        else:            query = lower_text.strip()                    if not query: return []        words = query.split()        result_tags = [self._clean_tag(w) for w in words]        return result_tags    @loader.command(ru_doc="[—Ç–µ–≥–∏] - –¥–æ–±–∞–≤–∏—Ç—å –º–µ–¥–∏–∞ (—Ä–µ–ø–ª–∞–µ–º). –ï—Å–ª–∏ —Ç–µ–≥–∏ –Ω–µ —É–∫–∞–∑–∞–Ω—ã, –±–µ—Ä–µ—Ç –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è.")    async def addmediacmd(self, message: Message):        """–î–æ–±–∞–≤–∏—Ç—å –º–µ–¥–∏–∞ –≤ –±–∞–∑—É. –ú–æ–∂–Ω–æ —É–∫–∞–∑–∞—Ç—å —Ç–µ–≥–∏."""        reply = await message.get_reply_message()        if not reply or not (reply.photo or reply.video or reply.gif or reply.document):            return await utils.answer(message, self.strings("not_media"))        saved = await self._client.send_message("me", message=reply.text or "", file=reply.media)        uid = f"{self.me_id}:{saved.id}"                if uid not in self.media_list:            self.media_list.append(uid)                args = utils.get_args_raw(message)        source = "Auto"        if args:            tags = [t.lower() for t in args.split()]            source = "Manual"        else:            tags = self._extract_hashtags(reply.text)                    if tags:            self.tags_db[uid] = tags                    tags_str = ", ".join(tags) or "None"        await utils.answer(message, self.strings("added").format(len(self.media_list), source, tags_str))    # –ö–æ–º–∞–Ω–¥–∞ edittagscmd —É–¥–∞–ª–µ–Ω–∞    # –ö–æ–º–∞–Ω–¥–∞ checktagscmd —É–¥–∞–ª–µ–Ω–∞        @loader.command(ru_doc="- —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞")    async def mediastatscmd(self, message: Message):        """–ü–æ–∫–∞–∑–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É –∏ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""        channels = self.config["channel"] or "Manual List"        await utils.answer(message, self.strings("stats").format(            len(self.media_list), len(self.sent_history), channels,             self.config["trigger_mode"],             self.config["min_duration"], self.config["max_duration"]        ))        @loader.command(ru_doc="- —Å–±—Ä–æ—Å –∏—Å—Ç–æ—Ä–∏–∏")    async def mediaresetcmd(self, message: Message):        """–°–±—Ä–æ—Å–∏—Ç—å –∏—Å—Ç–æ—Ä–∏—é –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–Ω—ã—Ö (–Ω–∞—á–∞—Ç—å —Ü–∏–∫–ª –∑–∞–Ω–æ–≤–æ)"""        self.sent_history.clear()        await utils.answer(message, self.strings("cleared"))    def _check_duration(self, msg):        if not (msg.video or msg.gif): return True        duration = 0        if hasattr(msg, "document") and msg.document:            for attr in msg.document.attributes:                if isinstance(attr, types.DocumentAttributeVideo):                    duration = attr.duration                    break        min_d = self.config["min_duration"]        max_d = self.config["max_duration"]        if min_d > 0 and duration < min_d: return False        if max_d > 0 and duration > max_d: return False        return True    def _check_type(self, msg):        target = self.config["media_type"]        if target == "all": return True        if target == "photo" and msg.photo: return True        if target == "video" and msg.video: return True        if target == "gif" and (msg.gif or (msg.video and not msg.audio)): return True        return False    def _check_tags(self, msg, uid, required_tags):        if not required_tags: return True        found_tags = set()                if uid in self.tags_db:            for t in self.tags_db[uid]:                found_tags.add(self._clean_tag(t))                if msg.text:            text_lower = msg.text.lower()            text_tags = self._extract_hashtags(msg.text)            for t in text_tags:                found_tags.add(self._clean_tag(t))            for req in required_tags:                if req in text_lower:                    found_tags.add(req)        return any(req in found_tags for req in required_tags)    def _get_uid(self, msg):        return f"{msg.chat_id}:{msg.id}"    async def _safe_send(self, reply_item, **kwargs):        """–ë–µ–∑–æ–ø–∞—Å–Ω–∞—è –æ—Ç–ø—Ä–∞–≤–∫–∞ —Å –æ–±—Ä–∞–±–æ—Ç–∫–æ–π –æ—à–∏–±–æ–∫ –ø—Ä–∞–≤ –¥–æ—Å—Ç—É–ø–∞"""        try:            await reply_item.reply(**kwargs)            return True        except (errors.ChatSendPhotosForbiddenError, errors.ChatSendMediaForbiddenError) as e:            logger.warning(f"AutoMedia: Forbidden to send media in {reply_item.chat_id}")            # –û–ø—Ü–∏–æ–Ω–∞–ª—å–Ω–æ: —É–≤–µ–¥–æ–º–∏—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, —á—Ç–æ —Ç—É—Ç –Ω–µ–ª—å–∑—è —Å–ª–∞—Ç—å —Ñ–æ—Ç–æ            # await utils.answer(reply_item, self.strings("send_err"))             return False        except errors.RPCError as e:            logger.error(f"AutoMedia RPC Error: {e}")            return False        except Exception as e:            logger.error(f"AutoMedia Generic Error: {e}")            return False    async def _fetch_from_channel(self, channel, required_tags, limit_count):        """–£–º–Ω—ã–π –ø–æ–∏—Å–∫ –º–µ–¥–∏–∞ –≤ –∫–∞–Ω–∞–ª–µ (Random Offset –∏–ª–∏ Server Search)"""        fetched = []        fetched_ids = set()                # –°–¢–†–ê–¢–ï–ì–ò–Ø 1: –ï—Å–ª–∏ –µ—Å—Ç—å —Ç–µ–≥–∏ - –∏—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–∏—Å–∫ Telegram (–ë–ï–ó –õ–ò–ú–ò–¢–ê –ì–õ–£–ë–ò–ù–´)        if required_tags:            # –ò—Ç–µ—Ä–∏—Ä—É–µ–º—Å—è –ø–æ –í–°–ï–ú —Ç–µ–≥–∞–º, —á—Ç–æ–±—ã –Ω–∞–π—Ç–∏ —Ö–æ—Ç—å —á—Ç–æ-—Ç–æ            for tag in required_tags:                if len(fetched) >= 50: break                                 try:                    count_found = 0                    async for msg in self._client.iter_messages(channel, search=tag, limit=None):                         if count_found >= 20: break                          if len(fetched) >= 50: break                                                   if not msg.media: continue                         if msg.id in fetched_ids: continue                                                  fetched.append(msg)                         fetched_ids.add(msg.id)                         count_found += 1                except Exception as e:                    logger.error(f"Search error in {channel} for {tag}: {e}")                # –°–¢–†–ê–¢–ï–ì–ò–Ø 2: –ï—Å–ª–∏ —Ç–µ–≥–æ–≤ –Ω–µ—Ç - Random Offset        else:            try:                total_msgs = (await self._client.get_messages(channel, limit=0)).total                if total_msgs > 50:                    for _ in range(5):                        offset = random.randint(0, total_msgs - 30)                        msgs = await self._client.get_messages(channel, limit=30, add_offset=offset)                        chunk_media = [m for m in msgs if m.media]                        if chunk_media:                            fetched.extend(chunk_media)                            break                else:                    msgs = await self._client.get_messages(channel, limit=50)                    for m in msgs:                        if m.media: fetched.append(m)            except Exception as e:                logger.error(f"Random offset error in {channel}: {e}")                        return fetched    @loader.watcher(only_messages=True, in_=True)    async def watcher(self, message: Message):        if time.time() - self.last_triggered < self.config["cooldown"]: return        if not message.text: return        text_lower = message.text.lower()        trigger_word = self.config["trigger_word"].lower()        mode = self.config["trigger_mode"]        # 1. –ü—Ä–æ–≤–µ—Ä—è–µ–º —É—Å–ª–æ–≤–∏—è —Ç—Ä–∏–≥–≥–µ—Ä–∞        is_reply_to_me = False        if message.is_reply:            reply = await message.get_reply_message()            if reply and reply.sender_id == self.me_id:                is_reply_to_me = True        has_trigger_word = trigger_word in text_lower                should_trigger = False        if mode == "text":            # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –µ—Å—Ç—å —Å–ª–æ–≤–æ-—Ç—Ä–∏–≥–≥–µ—Ä            if has_trigger_word: should_trigger = True                    elif mode == "reply":            # –¢–æ–ª—å–∫–æ –µ—Å–ª–∏ –æ—Ç–≤–µ—Ç –º–Ω–µ (—Å–ª–æ–≤–æ –Ω–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ, –Ω–æ –µ—Å–ª–∏ –µ—Å—Ç—å - –∏—Å–ø–æ–ª—å–∑—É–µ–º –¥–ª—è —Ç–µ–≥–æ–≤)            if is_reply_to_me: should_trigger = True                    elif mode == "any":            # –ò–ª–∏ —Å–ª–æ–≤–æ, –∏–ª–∏ –æ—Ç–≤–µ—Ç –º–Ω–µ            if has_trigger_word or is_reply_to_me: should_trigger = True        if not should_trigger: return        # 2. –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Ç–µ–≥–∏ –¥–ª—è –ø–æ–∏—Å–∫–∞        requested_tags = self._get_query_tags(text_lower, trigger_word)        count = self.config["send_count"]        candidates = []        try:            channels_config = self.config["channel"]                        # --- –†–ï–ñ–ò–ú –ö–ê–ù–ê–õ–û–í ---            if channels_config:                channel_list = [c.strip() for c in channels_config.split(",") if c.strip()]                target_channel = random.choice(channel_list) if channel_list else "me"                                raw_msgs = await self._fetch_from_channel(target_channel, requested_tags, count)                                for m in raw_msgs:                    uid = self._get_uid(m)                    if uid in self.sent_history: continue                    if not self._check_type(m): continue                    if not self._check_duration(m): continue                    if not self._check_tags(m, uid, requested_tags): continue                                        candidates.append(m)                if not candidates and self.config["loop_media"] and self.sent_history:                    if random.random() < 0.2: self.sent_history.clear()            # --- –†–£–ß–ù–û–ô –†–ï–ñ–ò–ú (Saved Messages) ---            else:                if not self.media_list: return                available_refs = list(self.media_list)                random.shuffle(available_refs)                                for ref in available_refs:                    if len(candidates) >= count + 2: break                    if ref in self.sent_history: continue                    try:                        chat_id, msg_id = map(int, ref.split(":"))                        msg = await self._client.get_messages(chat_id, ids=msg_id)                        if not msg:                            if ref in self.media_list: self.media_list.remove(ref)                            continue                        if not self._check_type(msg): continue                        if not self._check_duration(msg): continue                        if not self._check_tags(msg, ref, requested_tags): continue                        candidates.append(msg)                    except Exception: pass                if not candidates and self.config["loop_media"] and not requested_tags:                    self.sent_history.clear()            # --- –û–¢–ü–†–ê–í–ö–ê ---            if candidates:                selected = random.sample(candidates, min(len(candidates), count))                files_to_send = [m.media for m in selected]                                # –ò—Å–ø–æ–ª—å–∑—É–µ–º –±–µ–∑–æ–ø–∞—Å–Ω—É—é –æ—Ç–ø—Ä–∞–≤–∫—É                sent_ok = await self._safe_send(message, file=files_to_send)                                if sent_ok:                    for m in selected:                        uid = self._get_uid(m)                        if uid not in self.sent_history:                            self.sent_history.append(uid)                                        self.last_triggered = time.time()                        except Exception as e:            logger.exception(f"AutoMediaPro Critical Error: {e}")